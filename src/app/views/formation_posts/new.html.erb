<h1>新規投稿</h1>
<!-- form_for部分 -->

<%= form_for(@formation_post) do |f| %>

    <select id="match_schedule">
          <option>対戦カードを選択してください</option>

    </select>

    <h4>タイトル</h4>
    <%= f.text_field :title %>

    <h4>本文</h4>
    <%= f.text_area :body %>

<div>
    <canvas id="canvas" width=300 height=300></canvas>
</div>

    <%= f.submit '投稿', class:"btn btn-lg btn-block", id:"save-button" %>
    <%= f.hidden_field :coordinates, value: "" %>
    <%= f.hidden_field :image_url, value: "" %>

<div class="zone">
	<div class="zone-inner">
		<div id="wig_1" class="widget draggable ui-widget-content">
			<div class="widget-inner"></div>
			<h5 class="wig-txt text-center">drag me!</h5>
		</div>
		<div id="wig_2" class="widget draggable ui-widget-content">
			<div class="widget-inner"></div>
		</div>
		<div id="wig_3" class="widget draggable ui-widget-content">
			<div class="widget-inner"></div>
		</div>
	</div>
</div>
<script type="text/javascript" src="https://code.jquery.com/ui/1.12.0/jquery-ui.min.js"></script>
<script type="text/javascript">
    window.onload = function () {
        // canvas要素を取得
        var canvas = document.getElementById("canvas");
        // canvas要素が持つgetContext()メソッドを実行し、
        // グラフィック描画のためのメソッドやプロパティを
        // 持つオブジェクトを取得する。
        // 引数を"2d"とすることで2Dグラフィックの描画に
        // 特化したメソッドやプロパティを持つオブジェクトを取得し、
        // 定数ctxに格納する。
        var ctx = canvas.getContext("2d");
        // 定数ctxに格納したオブジェクトがもつプロパティやメソッドは
        // ctx.プロパティ名、ctx.メソッド名() で呼び出せる


        var BB = canvas.getBoundingClientRect();
        //左辺の座標
        var offsetX = BB.left;
        //四角形の上辺の座標
        var offsetY = BB.top;
        var WIDTH = canvas.width;
        var HEIGHT = canvas.height;

        var dragok = false;
        var startX;
        var startY;
        var dataURL =  canvas.toDataURL('image/png');
        console.log(window.location);
        //window.location = dataURL;

        var img = new Image();
        img.src = "/images/uni.jpg";
        img.onload = () => {
        draw();
        }

        var rects = [];
        rects.push({
        x: 220 - 10,
        y: 90 - 35,
        width: 30,
        height: 30,
        fill: "#444444",
        isDragging: false
        });
        rects.push({
        x: 140 - 10,
        y: 50 - 35,
        width: 30,
        height: 30,
        fill: "#ff550d",
        isDragging: false
        });
        rects.push({
        x: 60 - 10,
        y: 90 - 35,
        width: 30,
        height: 30,
        fill: "#800080",
        isDragging: false
        });
        rects.push({
        x: 100 - 10,
        y: 150 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });
        rects.push({
        x: 180 - 10,
        y: 150 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });
        rects.push({
        x: 140 - 10,
        y: 200 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });
        rects.push({
        x: 100 - 10,
        y: 250 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });
        rects.push({
        x: 180 - 10,
        y: 250 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });
        rects.push({
        x: 30 - 10,
        y: 220 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });
        rects.push({
        x: 260 - 10,
        y: 220 - 35,
        width: 30,
        height: 30,
        fill: "#0c64e8",
        isDragging: false
        });

    draw();

    var url = canvas.toDataURL('image/jpeg');
    document.getElementById("formation_post_image_url").value = url;

    function rect(x, y, w, h) {
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.closePath();
      ctx.fill();
    }
    //アニメーションの各フレームの開始時に必要
    function clear() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
    }

    function draw() {
        clear();
        ctx.fillStyle = "#FAF7F8";
        rect(0, 0, WIDTH, HEIGHT);

      for (var i = 0; i < rects.length; i++) {
        var r = rects[i];
        ctx.fillStyle = r.fill;

        //画像の場合
        ctx.drawImage(img, r.x, r.y, r.width, r.height);
      }


    }
    canvas.onmousedown = myDown;
    function myDown(e) {
      e.preventDefault();
      e.stopPropagation();
      //e.clientXはWEB画面全体のx座標（押した箇所のx座標）
      //offsetXはcanvasの左上のx座標
      var mx = parseInt(e.clientX - offsetX);
      var my = parseInt(e.clientY - offsetY);
      //アイコンを押したときのx座標とy座標を記録している
      dragok = false;
      for (var i = 0; i < rects.length; i++) {
        var r = rects[i];
        if (mx > r.x && mx < r.x + r.width && my > r.y && my < r.y + r.height) {
          dragok = true;
          r.isDragging = true;
        }
      }
      //startX,startYに最初アイコンをクリックした時の座標が記録される
      startX = mx;
      startY = my;
    }

    canvas.onmouseup = myUp;
    function myUp(e) {
        e.preventDefault();
        e.stopPropagation();

        dragok = false;

        for (var i = 0; i < rects.length; i++) {
            rects[i].isDragging = false;
        }
        document.getElementById('formation_post_coordinates').value = JSON.stringify(rects);

        url = canvas.toDataURL('image/jpeg');
        document.getElementById("formation_post_image_url").value = url;

    }

    canvas.onmousemove = myMove;
    function myMove(e) {
        if (dragok) {
          e.preventDefault();
          e.stopPropagation();

          var mx = parseInt(e.clientX - offsetX);
          var my = parseInt(e.clientY - offsetY);

          var dx = mx - startX;
          var dy = my - startY;

          for (var i = 0; i < rects.length; i++) {
            var r = rects[i];
            if (r.isDragging) {
              r.x += dx;
              r.y += dy;

            }
          }

          draw();

          startX = mx;
          startY = my;

          if(
            Math.abs(red.x - blue.x) < red.width/2 + blue.width/2 //横の判定
            &&
            Math.abs(red.y - blue.y) < red.height/2 + blue.height/2 //縦の判定
          ){
            console.log("hit"); // hit
          }

        }

      }

  async function callApi() {
    //const res = await fetch("http://api.football-data.org/v4/areas/", { mode: "no-cors" });
    //console.log(res)
    //const users = await res.json();

    const res = {
      "count": 272,
      "filters": {},
      "areas": [
          {
              "id": 2000,
              "name": "Afghanistan",
              "countryCode": "AFG",
              "flag": null,
              "parentAreaId": 2014,
              "parentArea": "Asia"
          },
          {
              "id": 2271,
              "name": "Zanzibar",
              "countryCode": "ZAN",
              "flag": null,
              "parentAreaId": 2001,
              "parentArea": "Africa"
          },
          {
              "id": 2272,
              "name": "Zimbabwe",
              "countryCode": "ZIM",
              "flag": null,
              "parentAreaId": 2001,
              "parentArea": "Africa"
          }
      ]

    }
     // selectタグを取得する
    var Element = document.getElementById("match_schedule");
    var option = []
    console.log(res.areas[0].name)

    for (var i = 0; i<res.areas.length; i++) {
      // optionタグを作成する
      var option = document.createElement("option");
      option.value = res.areas[i].name;
      option.innerText = res.areas[i].name;
      Element.appendChild(option);
    }
      console.log(option);
    }
  callApi();



  $(function() {
	var xSave;
	var ySave;
	$( ".widget" ).draggable({
		containment: 'parent',
		grid: [50,50],
		stack: '.widget',
		start: function(event,ui) {
			// save coordinates for collision detection.
			xSave = $(this).position().left;
			ySave = $(this).position().top;
			var $el = $(this);
			var $elSibs = $(this).siblings('.widget');
			// DETECT COLLISION
			$elSibs.each(function() {
				var self = this;
				var $sib = $(self);
				collision($sib, $el);
			});
		},

		stop: function(event,ui) {
			var $el = $(this);
			var $elSibs = $(this).siblings('.widget');
			$el.removeClass('dragging');
			$elSibs.addClass('not-dragging');
			// DETECT COLLISION
			$elSibs.each(function() {
				var self = this;
				var $sib = $(self);
				collision($sib, $el);
				var result = collision($sib, $el);
				// if there is collision, we send back to start position.
				if(result == true) {
					$el.css({'top':ySave, 'left':xSave});
					$sib.find('.widget-inner').removeClass('collision');
				}
			});
		}
	});

	// Collision detection
	function collision($sib, $el) {
		var sibInner = $sib.find('.widget-inner');
		var wigInner = $el.find('.widget-inner');
		var x1 = wigInner.offset().left;
		var y1 = wigInner.offset().top;
		var h1 = wigInner.outerHeight(true);
		var w1 = wigInner.outerWidth(true);
		var b1 = y1 + h1;
		var r1 = x1 + w1;
		var x2 = sibInner.offset().left;
		var y2 = sibInner.offset().top;
		var h2 = sibInner.outerHeight(true);
		var w2 = sibInner.outerWidth(true);
		var b2 = y2 + h2;
		var r2 = x2 + w2;

		// CHECK FOR COLLISION
		if (	 (r1 >= x2 && b1 >= y2 && y1 < y2 && x1 < r2)
				|| (x1 <= r2 && b1 >= y2 && y1 < y2 && r1 > r2)
				|| (r1 >= x2 && y1 <= b2 && b1 > b2 && x1 < x2)
				|| (x1 <= r2 && y1 <= b2 && b1 > b2 && r1 > r2)
				|| (y1 == y2 && r1 == r2 && b1 == b2 && x1 == x2)
				|| (y1 >= y2 && x1 < r2 && b1 <= b2 && r1 > r2)
				|| (y1 >= y2 && r1 >= x2 && b1 <= b2 && x1 < x2)
				|| (x1 >= x2 && r1 <= r2 && y1 <= b2 && b1 > b2)
				|| (x1 >= x2 && y1 >= y2 && b1 <= b2 && r1 <= r2)
			 )
		{
			sibInner.addClass('collision');
			return true;
		} else {
			sibInner.removeClass('collision');
		}
	}

});

  };


</script>

<% end %>